<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LucasLYF</title>
  
  <subtitle>浮生万千，幸会矣！</subtitle>
  <link href="http://lucaslyf.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://lucaslyf.gitee.io/"/>
  <updated>2022-11-15T08:38:12.685Z</updated>
  <id>http://lucaslyf.gitee.io/</id>
  
  <author>
    <name>人是鳄鱼的子孙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lucrame:(问题记录)</title>
    <link href="http://lucaslyf.gitee.io/2022/03/06/Lucrame-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://lucaslyf.gitee.io/2022/03/06/Lucrame-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-03-05T19:29:25.000Z</published>
    <updated>2022-11-15T08:38:12.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;此贴主要记录Lucrame跨平台应用框架开发过程中遇到的奇怪和难点问题。</p><h2 id="Mac平台-Lucram在QtCreator中Debug闪退"><a href="#Mac平台-Lucram在QtCreator中Debug闪退" class="headerlink" title="(Mac平台)Lucram在QtCreator中Debug闪退"></a>(Mac平台)Lucram在QtCreator中Debug闪退</h2><p>&emsp;&emsp;因为项目设置了文件结构，会将生成目录下所需文件复制到指定目录。如果先直接运行，会在指定目录生成Lucrame可执行文件。此时再进行Debug，Qt检测到指定目录下存在同名文件，不会直接替换，而选择直接对其Debug，但运行生成的可执行文件和Debug生成的可执行文件有差异，因此无法Debug，导致直接闪退。此时只需要将指定目录下运行生成的Lucrame可执行文件删除，再进行Debug操作即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;此贴主要记录Lucrame跨平台应用框架开发过程中遇到的奇怪和难点问题。&lt;/p&gt;
&lt;h2 id=&quot;Mac平台-Luc</summary>
      
    
    
    
    <category term="Lucrame跨平台CAM应用框架" scheme="http://lucaslyf.gitee.io/categories/Lucrame%E8%B7%A8%E5%B9%B3%E5%8F%B0CAM%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Lucrame:(二)项目结构</title>
    <link href="http://lucaslyf.gitee.io/2022/03/04/Lucrame-%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://lucaslyf.gitee.io/2022/03/04/Lucrame-%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-04T15:40:31.000Z</published>
    <updated>2022-11-15T08:55:39.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;Lucrame跨平台应用框架利用QT插件特性，以<code>插件</code>的形式将功能模块化，方便后期拓展。本章节将详细介绍Lucrame-SDK开发包的目录结构，也希望各位开发者能够按照这样的文件结构进行开发（当然也可以自己设计合适的项目文件结构）。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">+|--Lucrame-SDK #开发包文件夹    +|--Contents #标准bundle文件结构        *|--_CodeSignature #一般为AppStore上架程序包含，内含数字签名防止非法篡改。         |--Frameworks #放置了该应用所引用的第三方库.dylib（可以理解为Win平台的dll动态链接库）。         |--MacOS #可执行文件（相当于Win平台的.exe）。         |--Plugins #插件文件夹，内涵.so(bundle)和.dylib，.so其实算是类Unix系统动态链接库的另一个格式。         |--Resources #资源文件，包含应用图标、图片、语言包等各种文件。         |--Info.plist #包含程序基本信息，标准的XML文档。         |--PkgInfo #可选的8字节文件，保存程序类型和开发者签名（也可以写在.plist中）。    +|--src #项目源码文件夹        +|--Lucrame #应用框架程序源码            *|--CuteLogger #第三方日志源码（LGPL开源协议），非必需。            *|--drmingw #一个应用于Win的即时调试器，程序崩溃时抛出错误信息，建议保留。             |--icons #存放资源文件（图片、.qrc、主题设置文件等）.             |--packaging #存放应用信息及应用图标。             |--Frame #主框架源码文件（.h&#x2F;.cpp&#x2F;.ui），以及项目设置文件（.pro&#x2F;.pri）。             |--Lucrame.pri #QT版本匹配，也可以将头文件引用等放入此处。             |--Lucrame.pro #项目设置文件，添加源文件、资源文件、链接第三方库等操作（相当于CMakeLists.txt）。        |--Plugins #插件开发源码(文件结构和应用框架类似，.pro文件略有不同，后续详述)。</code></pre><h3 id="Win"><a href="#Win" class="headerlink" title="Win"></a>Win</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">+|--Lucrame-SDK #开发包文件夹。     |--include #开发时需要，第三方库头文件。     |--lib #开发时需要，第三方库文件。     |--plugins #开发、发布时均需要，插件文件夹。    +|--src #项目源码文件夹        +|--Lucrame #应用框架程序源码            *|--CuteLogger #第三方日志源码（LGPL开源协议），非必需。            *|--drmingw #一个应用于Win的即时调试器，程序崩溃时抛出错误信息，建议保留。             |--icons #存放资源文件（图片、.qrc、主题设置文件等）.             |--packaging #存放应用信息及应用图标。             |--Frame #主框架源码文件（.h&#x2F;.cpp&#x2F;.ui），以及项目设置文件（.pro&#x2F;.pri）。             |--Lucrame.pri #QT版本匹配，也可以将头文件引用等放入此处。             |--Lucrame.pro #项目设置文件，添加源文件、资源文件、链接第三方库等操作（相当于CMakeLists.txt）。        |--Plugins #插件开发源码(文件结构和应用框架类似，.pro文件略有不同，后续详述)。     |--.dll&#x2F;.exe&#x2F;.ini&#x2F;... #必要文件，开发、发布时均需要。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lucrame跨平台应用框架利用QT插件特性，以&lt;code&gt;插件&lt;/code&gt;的形式将功能模块化，方便后期拓展。本章</summary>
      
    
    
    
    <category term="Lucrame跨平台CAM应用框架" scheme="http://lucaslyf.gitee.io/categories/Lucrame%E8%B7%A8%E5%B9%B3%E5%8F%B0CAM%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Lucrame:(一)环境搭建</title>
    <link href="http://lucaslyf.gitee.io/2022/03/03/Lucrame-%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://lucaslyf.gitee.io/2022/03/03/Lucrame-%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-02T16:00:20.000Z</published>
    <updated>2022-11-15T08:38:12.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;Lucrame跨平台CAM应用框架基于Qt6.2.3进行搭建，使用qmake进行项目管理(目前已经在<code>macOS M1 Big Sur </code>和<code>Window10</code>平台进行测试)。基于QT插件系统框架，该应用框架也将采用插件模式进行开发（也可以直接在主框架中修改源码开发，建议采用插件方式开发，有利于模块划分和功能扩展）。<br>接下来详细介绍SDK包的环境搭建步骤。</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h3><p>&emsp;&emsp;<a href="https://www.qt.io/download">Qt官网进行下载</a>,注册一个自己的账号，点击如图所示进行Qt在线安装包下载。<br><img src="%E4%B8%8B%E8%BD%BDQt.jpg" alt="Qt下载"><br>&emsp;&emsp;Qt安装方式为在线安装，可能比较慢，耐心等待一下就好。后期修改版本或者增添新组件比较方便。<br>&emsp;&emsp;下载完成后打开Qt在线安装，按照如图所示，勾选红框处，其余保持默认。<br><img src="Qt%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE(Mac).png" alt="Qt安装(Mac)"><img src="Qt%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE(Win).png" alt="Qt安装(Win)"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="下载配置SDK开发包"><a href="#下载配置SDK开发包" class="headerlink" title="下载配置SDK开发包"></a>下载配置SDK开发包</h3><p>&emsp;&emsp;下载SDK包：<a href="https://gitee.com/lucaslyf/lucrame-sdk-mac.git">Mac版本</a>，<a href="https://gitee.com/lucaslyf/lucrame-sdk-win.git">Win版本</a>。</p><h3 id="主框架项目配置"><a href="#主框架项目配置" class="headerlink" title="主框架项目配置"></a>主框架项目配置</h3><p>&emsp;&emsp;1.下载解压后进入到<code>Lucrame-SDK/src/Lucrame</code>目录下，双击<code>Lucrame.pro</code>打开Qt工程，构建项目选择<code>[Mac]:Qt6.2.3 for macOS</code>，<code>[Win]:Qt6.2.3 MinGW</code>。<br>&emsp;&emsp;2.切换到<code>Build</code>下面的<code>Run</code>设置面板，在<code>Deployment</code>下，点击<code>Add Deploy Step</code>，选择<code>Make</code>,在<code>Make arguments</code>中输入<code>install</code>。在<code>Run</code>下，点击<code>Add</code>选择<code>Custom Executable</code>，点击<code>Create</code>，在<code>Executable</code>中，Win填入<code>D:\Lucrame\Lucrame.exe</code>，Mac填入<code>/Users/xxxx/Documents/Lucrame/Contents/MacOS/Lucrame</code>，自行替换为自己的项目路径。<br><img src="%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE-Run(Win).png" alt="项目配置(Win)"><br><img src="%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE-Run(Win,Mac).png" alt="项目配置(Win,Mac)"></p><blockquote><p><em><strong>[Mac额外步骤:]</strong></em><br>&emsp;&emsp;3.再次点击<code>Add Deploy Step</code>，选择<code>Custom Process Step</code>，<code>Command</code>中输入<code>/bin/cp</code>，<code>Arguments</code>中输入<code>-p Frame/Lucrame.app/Contents/MacOS/Lucrame ../../Contents/MacOS</code>。<br><font color=#008000>//Mac:将生成的Lucrame.app应用文件bundle文件结构中的Lucrame执行文件复制到外部bundle结构下，发布时只需要删除src文件夹，在项目文件夹Lucrame后添加.app后缀即可直接发布。Win:Windows平台无需该步骤，发布时直接删除src文件夹，将上级Lucrame文件夹打包发布即可。</font><br><img src="%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE-Run(Mac).png" alt="项目配置(Mac)"></p></blockquote><p>&emsp;&emsp;做完以上所有操作后，点击绿色小三角运行。<br><img src="%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C(Mac).png" alt="项目运行(Mac)"><img src="%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C(Win).png" alt="项目运行(Win)"></p><h3 id="插件项目配置"><a href="#插件项目配置" class="headerlink" title="插件项目配置"></a>插件项目配置</h3><p>&emsp;&emsp;1.进入到<code>Lucrame-SDK/src/Plugins</code>目录下，双击<code>Plugins.pro</code>打开Qt工程，构建项目选择<code>[Mac]:Qt6.2.3 for macOS</code>，<code>[Win]:Qt6.2.3 MinGW</code>。<br>&emsp;&emsp;2.项目构建后，点击<code>项目(Projects)</code>小扳手图标，选择<code>Build</code>，在<code>Build Steps</code>下展开<code>Make</code>,在<code>Make arguments</code>中输入<code>install</code>。<br><img src="Plugins%E9%85%8D%E7%BD%AE.png" alt="Plugins项目配置"></p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>&emsp;&emsp;1.先安装Qt再配置SDK开发包，不然会出现找不到Qt Plugin的情况。<br>&emsp;&emsp;2.Mac:初次运行时在<code>Lucrame-SDK/Contents/MacOS</code>文件夹下没有Lucrame文件，在电脑中随便找一个app，<code>右键-Show Package Contents-Contents-MacOS</code>进入该目录，将里面的可执行文件复制到<code>Lucrame-SDK/Contents/MacOS</code>目录下，修改名字为<code>Lucrame</code>，重新构建，运行即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lucrame跨平台CAM应用框架基于Qt6.2.3进行搭建，使用qmake进行项目管理(目前已经在&lt;code&gt;ma</summary>
      
    
    
    
    <category term="Lucrame跨平台CAM应用框架" scheme="http://lucaslyf.gitee.io/categories/Lucrame%E8%B7%A8%E5%B9%B3%E5%8F%B0CAM%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>RobotCAM(四):基于VTK的桌面软件显示模块代码介绍</title>
    <link href="http://lucaslyf.gitee.io/2021/11/04/RobotCAM-%E5%9B%9B-%E5%9F%BA%E4%BA%8EVTK%E7%9A%84%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
    <id>http://lucaslyf.gitee.io/2021/11/04/RobotCAM-%E5%9B%9B-%E5%9F%BA%E4%BA%8EVTK%E7%9A%84%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-11-04T14:46:29.000Z</published>
    <updated>2022-11-15T08:38:12.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;因为RobotCAM软件平台是面向机器人仿真加工和CAM方向的桌面应用软件平台。因此需要用到大量三维显示，平台选用VTK显示库（BSD开源协议），本章节主要介绍VTK显示模块的基本代码。</p><h3 id="pcbDisplayInterface-h"><a href="#pcbDisplayInterface-h" class="headerlink" title="pcbDisplayInterface.h"></a>pcbDisplayInterface.h</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#pragma once#include &lt;windows.h&gt;class vtkRenderWindow;class vtkRenderer;class vtkRenderWindowInteractor;class vtkPlaneSource;class vtkActor;class vtkTextActor;class vtkOrientationMarkerWidget;class pbcDisplayInterface&#123;public:    &#x2F;&#x2F;静态成员变量：VTK渲染窗口    static vtkRenderWindow *s_RenWin;    &#x2F;&#x2F;静态成员变量：2D视窗渲染器    static vtkRenderer *s_Renderer2D;    &#x2F;&#x2F;静态成员变量：3D视窗渲染器    static vtkRenderer *s_Renderer3D;    &#x2F;&#x2F;静态成员变量：    static double s_ViewPort[4];    static int s_BGGradient;    static double s_BGColor[6];    static vtkActor *s_FloorActor;    &#x2F;&#x2F;初始化VTK窗口，将VTK窗口绑定到对应的QT控件（传入窗口大小和窗口句柄）    bool InitializeVTKWindow(double* rectClient, HWND viewHwnd);    &#x2F;&#x2F;调整显示参数（三角面数量）    bool AdjustParameterDisplay();    &#x2F;&#x2F;调整窗口大小    void AdjustWinDisplay(double* rectClient);private:    static vtkRenderWindowInteractor *s_RenInter;    static vtkPlaneSource *s_GroundSource;    static vtkTextActor *s_PolyNumber;    static vtkOrientationMarkerWidget *s_AxisWidget;    &#x2F;&#x2F;读取用户设置    bool ReadUserSettings();    &#x2F;&#x2F;初始化交互风格    bool InitializeInteractionStyle();    &#x2F;&#x2F;初始化显示环境    bool InitializeEnvironment();    &#x2F;&#x2F;初始化参数显示    bool InitializeParameterDisplay();    &#x2F;&#x2F;初始化坐标轴显示    bool InitializeAxisDisplay();&#125;;</code></pre><h3 id="pcbDisplayInterface-cpp"><a href="#pcbDisplayInterface-cpp" class="headerlink" title="pcbDisplayInterface.cpp"></a>pcbDisplayInterface.cpp</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;pbcDisplayInterface.h&quot;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderer.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt;#include &lt;vtkInteractorStyleTrackballCamera.h&gt;#include &lt;vtkSmartPointer.h&gt;#include &lt;vtkPlaneSource.h&gt;#include &lt;vtkPolyDataMapper.h&gt;#include &lt;vtkActor.h&gt;#include &lt;vtkProperty.h&gt;#include &lt;vtkTextActor.h&gt;#include &lt;vtkTextProperty.h&gt;#include &lt;vtkAxesActor.h&gt;#include &lt;vtkCaptionActor2D.h&gt;#include &lt;vtkOrientationMarkerWidget.h&gt;vtkRenderWindow *evaDisplayInterface::s_RenWin&#x3D; vtkRenderWindow::New();vtkRenderer *evaDisplayInterface::s_Renderer3D &#x3D; vtkRenderer::New();vtkRenderer *evaDisplayInterface::s_Renderer2D &#x3D; vtkRenderer::New();vtkRenderWindowInteractor *evaDisplayInterface::s_RenInter &#x3D; vtkRenderWindowInteractor::New();vtkPlaneSource *evaDisplayInterface::s_GroundSource &#x3D; vtkPlaneSource::New();vtkActor *evaDisplayInterface::s_FloorActor &#x3D; vtkActor::New();vtkTextActor *evaDisplayInterface::s_PolyNumber &#x3D; vtkTextActor::New();vtkOrientationMarkerWidget *evaDisplayInterface::s_AxisWidget &#x3D; vtkOrientationMarkerWidget::New();int pbcDisplayInterface::s_BGGradient;double pbcDisplayInterface::s_BGColor[6];double pbcDisplayInterface::s_ViewPort[4];bool pbcDisplayInterface::InitializeVTKWindow(double* rectClient, HWND viewHwnd)&#123;    s_RenWin-&gt;SetSize(rectClient[0], rectClient[1]);    s_RenWin-&gt;SetParentId(viewHwnd);    s_RenWin-&gt;SetNumberOfLayers(2);    ReadUserSettings();    s_Renderer3D-&gt;SetLayer(0);    s_Renderer2D-&gt;SetLayer(1);    s_ViewPort[0]&#x3D;0;    s_ViewPort[1]&#x3D;0.5;    s_ViewPort[2]&#x3D;0.5;    s_ViewPort[3]&#x3D;1;    s_Renderer2D-&gt;SetViewport(s_ViewPort);    s_RenWin-&gt;AddRenderer(s_Renderer3D);    s_RenWin-&gt;AddRenderer(s_Renderer2D);    s_RenInter-&gt;SetRenderWindow(s_RenWin);    if(!InitializeInteractionStyle()||!InitializeEnvironment()||!InitializeAxisDisplay()||!InitializeParameterDisplay())    &#123;        return false;    &#125;    s_Renderer3D-&gt;ResetCamera();    s_Renderer3D-&gt;ResetCameraClippingRange();    s_RenWin-&gt;Render();    s_RenInter-&gt;Initialize();    s_RenInter-&gt;Render();    return true;&#125;bool pbcDisplayInterface::InitializeInteractionStyle()&#123;    vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; defaultInteractorStyle &#x3D;        vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::New();    defaultInteractorStyle-&gt;SetDefaultRenderer(s_Renderer3D);    s_RenInter-&gt;SetInteractorStyle(defaultInteractorStyle);    return s_RenInter-&gt;GetInteractorStyle();&#125;bool pbcDisplayInterface::InitializeEnvironment()&#123;    &#x2F;&#x2F;初始化地面    int rlt &#x3D; 4; &#x2F;&#x2F; x,y方向上的方格数量    int sqrLen &#x3D; 1000; &#x2F;&#x2F; 方格的边长    s_GroundSource-&gt;SetOrigin(0, 0, 0);    s_GroundSource-&gt;SetPoint1(rlt*sqrLen, 0, 0);    s_GroundSource-&gt;SetPoint2(0, rlt*sqrLen, 0);    s_GroundSource-&gt;SetResolution(rlt, rlt);    s_GroundSource-&gt;SetCenter(0.0, 0.0, 0.0);    s_GroundSource-&gt;Update();    vtkSmartPointer&lt;vtkPolyDataMapper&gt; floorPolyDataMapper &#x3D; vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();    floorPolyDataMapper-&gt;SetInputData(s_GroundSource-&gt;GetOutput());    s_FloorActor-&gt;SetMapper(floorPolyDataMapper);    s_FloorActor-&gt;GetProperty()-&gt;SetEdgeVisibility(1);    s_FloorActor-&gt;GetProperty()-&gt;SetEdgeColor(0, 0, 0);    s_FloorActor-&gt;GetProperty()-&gt;SetLineWidth(2);    s_FloorActor-&gt;GetProperty()-&gt;SetLighting(false);    s_FloorActor-&gt;PickableOff();    s_Renderer3D-&gt;AddActor(s_FloorActor);    return s_Renderer3D-&gt;GetActors();&#125;bool pbcDisplayInterface::InitializeParameterDisplay()&#123;    double size[2];    s_PolyNumber-&gt;SetInput(&quot;0&quot;);    s_Renderer3D-&gt;AddActor(s_PolyNumber);    s_PolyNumber-&gt;GetSize(s_Renderer3D, size);    int *winSize &#x3D; s_RenWin-&gt;GetSize();    if(winSize&#x3D;&#x3D;NULL)    &#123;        return false;    &#125;    s_PolyNumber-&gt;SetDisplayPosition(winSize[0] - size[0] &#x2F; 2 - 10, winSize[1] - size[1] - 10);    s_PolyNumber-&gt;GetActualPosition2Coordinate()-&gt;SetCoordinateSystemToNormalizedViewport();    s_PolyNumber-&gt;GetTextProperty()-&gt;SetFontSize(15);    s_PolyNumber-&gt;GetTextProperty()-&gt;SetFontFamilyToArial();    s_PolyNumber-&gt;GetTextProperty()-&gt;SetJustificationToCentered();    s_PolyNumber-&gt;GetTextProperty()-&gt;BoldOn();    s_PolyNumber-&gt;GetTextProperty()-&gt;ItalicOn();    s_PolyNumber-&gt;GetTextProperty()-&gt;SetColor(0, 0, 0);    return true;&#125;bool pbcDisplayInterface::InitializeAxisDisplay()&#123;    vtkSmartPointer&lt;vtkAxesActor&gt; axisActor &#x3D; vtkSmartPointer&lt;vtkAxesActor&gt;::New();    axisActor-&gt;GetXAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;SetColor(1, 0, 0);&#x2F;&#x2F;修改X字体颜色为红色    axisActor-&gt;GetYAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;SetColor(0, 1, 0);&#x2F;&#x2F;修改Y字体颜色为绿色    axisActor-&gt;GetZAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;SetColor(0, 0, 1);&#x2F;&#x2F;修改Z字体颜色为蓝色    axisActor-&gt;SetShaftTypeToCylinder();    axisActor-&gt;SetTipTypeToCone();    axisActor-&gt;SetCylinderRadius(1.5 * axisActor-&gt;GetCylinderRadius());    axisActor-&gt;SetConeRadius(1.5 * axisActor-&gt;GetConeRadius());    axisActor-&gt;SetSphereRadius(1.5 * axisActor-&gt;GetSphereRadius());    axisActor-&gt;GetXAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;ShadowOff();    axisActor-&gt;GetYAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;ShadowOff();    axisActor-&gt;GetZAxisCaptionActor2D()-&gt;GetCaptionTextProperty()-&gt;ShadowOff();    s_AxisWidget-&gt;SetOutlineColor(0.9300, 0.5700, 0.1300);    s_AxisWidget-&gt;SetOrientationMarker(axisActor);    s_AxisWidget-&gt;SetInteractor(s_RenInter);    s_AxisWidget-&gt;SetViewport(0.0, 0.0, 0.07, 0.1);    s_AxisWidget-&gt;SetEnabled(1);    s_AxisWidget-&gt;InteractiveOff();    return s_AxisWidget-&gt;GetOrientationMarker();&#125;bool pbcDisplayInterface::ReadUserSettings()&#123;    &#x2F;&#x2F;读取用户背景颜色设置    ifstream BackgroundSetting;    BackgroundSetting.open(&quot;..\\..\\.\\UserData\\DisplaySettings\\UserBackgroundSetting.txt&quot;);    if (!BackgroundSetting.is_open())    &#123;        cout &lt;&lt; &quot;DefaultSettings is damaged&quot; &lt;&lt; endl;        return false;    &#125;    for (int i &#x3D; 0; i &lt; 1; i++)    &#123;        BackgroundSetting &gt;&gt; s_BGGradient;    &#125;    for (int i &#x3D; 0; i &lt; 6; i++)    &#123;        BackgroundSetting &gt;&gt; s_BGColor[i];    &#125;    s_Renderer2D-&gt;SetBackground(s_BGColor[0] &#x2F; 255.0, s_BGColor[1] &#x2F; 255.0, s_BGColor[2] &#x2F; 255.0);    s_Renderer2D-&gt;SetBackground2(s_BGColor[3] &#x2F; 255.0, s_BGColor[4] &#x2F; 255.0, s_BGColor[5] &#x2F; 255.0);    s_Renderer2D-&gt;SetGradientBackground(s_BGGradient);    s_Renderer3D-&gt;SetBackground(s_BGColor[0] &#x2F; 255.0, s_BGColor[1] &#x2F; 255.0, s_BGColor[2] &#x2F; 255.0);    s_Renderer3D-&gt;SetBackground2(s_BGColor[3] &#x2F; 255.0, s_BGColor[4] &#x2F; 255.0, s_BGColor[5] &#x2F; 255.0);    s_Renderer3D-&gt;SetGradientBackground(s_BGGradient);    s_RenWin-&gt;Render();    return true;&#125;void pbcDisplayInterface::AdjustWinDisplay(double* rectClient)&#123;    s_RenWin-&gt;SetSize(rectClient[0], rectClient[1]);&#125;bool pbcDisplayInterface::AdjustParameterDisplay()&#123;    double size[2];    s_PolyNumber-&gt;GetSize(s_Renderer3D, size);    int *winSize &#x3D; s_RenWin-&gt;GetSize();    if(winSize&#x3D;&#x3D;NULL)    &#123;        return false;    &#125;    s_PolyNumber-&gt;SetDisplayPosition(winSize[0] - size[0] &#x2F; 2 - 10, winSize[1] - size[1] - 10);    return true;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;因为RobotCAM软件平台是面向机器人仿真加工和CAM方向的桌面应用软件平台。因此需要用到大量三维显示，平台选用V</summary>
      
    
    
    
    <category term="RobotCAM软件开发" scheme="http://lucaslyf.gitee.io/categories/RobotCAM%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RobotCAM(三):基于QT的桌面软件开发通用平台基本代码介绍</title>
    <link href="http://lucaslyf.gitee.io/2021/08/03/RobotCAM-%E4%B8%89-%E5%9F%BA%E4%BA%8EQT%E7%9A%84%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E5%B9%B3%E5%8F%B0%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
    <id>http://lucaslyf.gitee.io/2021/08/03/RobotCAM-%E4%B8%89-%E5%9F%BA%E4%BA%8EQT%E7%9A%84%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E5%B9%B3%E5%8F%B0%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-08-03T08:15:03.000Z</published>
    <updated>2022-11-15T08:55:27.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;通用平台框架基于QT编写（LGPL开源协议，商业友好型，独立封装只需开源QT模块代码），使用C++语言，可视化部分使用VTK开源库（BSD开源协议，商业友好型，不修改源码无需开源）。<br>&emsp;&emsp;整个项目使用CMake进行模块化管理（CMake相比于QMake更加通用），动态加载模块（插件）。</p><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;包含主窗口头文件#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;初始化资源文件    Q_INIT_RESOURCE(Public);    QApplication app(argc, argv);    &#x2F;&#x2F;创建一个主窗口对象    MainWindow w;    &#x2F;&#x2F;调用主窗口对象的初始化函数    w.initMainWindow();    &#x2F;&#x2F;显示主窗口    w.show();    return app.exec();&#125;</code></pre><h3 id="mainwindow-h"><a href="#mainwindow-h" class="headerlink" title="mainwindow.h"></a>mainwindow.h</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;避免重复包含头文件#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QtWidgets&gt;#include &lt;QtGui&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    &#x2F;&#x2F;构造函数，指定父对象    MainWindow(QWidget *parent &#x3D; nullptr);    &#x2F;&#x2F;析构函数    ~MainWindow();    &#x2F;&#x2F;初始化主窗口    bool initMainWindow();private:    Ui::MainWindow *ui;    &#x2F;&#x2F;重写大小变化事件    void resizeEvent(QResizeEvent * event);    &#x2F;&#x2F;初始化VTK显示    bool initVTKWidget();&#125;;#endif &#x2F;&#x2F; MAINWINDOW_H</code></pre><h2 id="mainwindow-cpp"><a href="#mainwindow-cpp" class="headerlink" title="mainwindow.cpp"></a>mainwindow.cpp</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;mainwindow.h&quot;#include &quot;.&#x2F;ui_mainwindow.h&quot;#include &quot;evaDisplayInterface.h&quot;#include &lt;vtkRenderWindow.h&gt;#include &lt;vtkRenderWindowInteractor.h&gt;#include &lt;vtkInteractorObserver.h&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;bool MainWindow::initMainWindow()&#123;    &#x2F;&#x2F;初始化主窗体，修正各控件尺寸大小    this-&gt;setAttribute(Qt::WA_DontShowOnScreen);    this-&gt;show();    this-&gt;hide();    this-&gt;setAttribute(Qt::WA_DontShowOnScreen, false);    &#x2F;&#x2F;这一段代码是为了刷新控件尺寸    this-&gt;setWindowTitle(&quot;RobotCAM&quot;);    this-&gt;setWindowIcon(QIcon(&quot;:&#x2F;images&#x2F;RobotCAM.png&quot;));    initVTKWidget();    return true;&#125;bool MainWindow::initVTKWidget()&#123;    evaDisplayInterface displayInterface;    double mainWinRect[2];    mainWinRect[0] &#x3D;ui-&gt;widget-&gt;rect().right();    mainWinRect[1] &#x3D;ui-&gt;widget-&gt;rect().bottom();    &#x2F;&#x2F;绑定窗口    displayInterface.InitializeVTKWindow(mainWinRect, (HWND)ui-&gt;widget-&gt;winId());    return true;&#125;void MainWindow::resizeEvent(QResizeEvent * event)&#123;    QWidget::resizeEvent(event);    if( ui-&gt;widget-&gt;rect().height()&gt;50)    &#123;        &#x2F;&#x2F;获取VTK窗口对应的QTWidget控件大小        double mainWinRect[2];        mainWinRect[0] &#x3D;ui-&gt;widget-&gt;rect().right();        mainWinRect[1] &#x3D;ui-&gt;widget-&gt;rect().bottom();        evaDisplayInterface displayInterface;        displayInterface.AdjustWinDisplay(mainWinRect);        displayInterface.AdjustParameterDisplay();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;通用平台框架基于QT编写（LGPL开源协议，商业友好型，独立封装只需开源QT模块代码），使用C++语言，可视化部分使</summary>
      
    
    
    
    <category term="RobotCAM软件开发" scheme="http://lucaslyf.gitee.io/categories/RobotCAM%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RobotCAM(二):CMake简单介绍</title>
    <link href="http://lucaslyf.gitee.io/2021/08/02/RobotCAM-%E4%BA%8C-CMake%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://lucaslyf.gitee.io/2021/08/02/RobotCAM-%E4%BA%8C-CMake%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-08-02T02:40:48.000Z</published>
    <updated>2022-11-15T08:38:12.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;简单介绍CMake软件即CMakeLists.txt作用和功能。<br>&emsp;&emsp;CMmke常用于跨平台编译，在我们的项目中主要用来进行QT的编译设置和模块化管理。<br>&emsp;&emsp;利用CMake语句进行第三方库配置，链接模块，具有结构清晰的优点。</p><h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">+|--Public #项目文件夹     |--bin #编译后产生的文件（lib、dll、exe）    +|--Public_QT #QT框架模块         |--inc #头文件夹（存放.h文件）        +|--res #资源文件夹（存放图片资源文件等）             |--Public.qrc #qt资源文件，类似于MFC的.rc文件，存储资源路径         |--src #源文件夹（存放.cpp源文件和.uiQT设计师文件，运行时.ui文件会被QT编译为ui_xxx.h头文件）         |--CMakeLists.txt #模块CMake配置文件（下面详述）     |--Public_VTK #VTK显示模块     |--third_part_library #第三方库     |--UserData #用户数据     |--.gitignore #gitee忽略配置（团队协同开发时需要用到代码管理工具，处理代码合并冲突等问题，此配置为忽略掉特定文件上传）     |--CMakeLists.txt #顶层CMake配置文件（项目模块管理文件）</code></pre><h2 id="顶层CMakeLists-txt"><a href="#顶层CMakeLists-txt" class="headerlink" title="顶层CMakeLists.txt"></a>顶层CMakeLists.txt</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">CMAKE_MINIMUM_REQUIRED( VERSION 3.19.2 ) #CMake最低版本限制，低于这个版本提示报错PROJECT(Public_Project) #生成工程Public_ProjectADD_SUBDIRECTORY(Public_QT) #添加QT模块ADD_SUBDIRECTORY(Public_VTK) #添加VTK模块ADD_SUBDIRECTORY(&quot;模块名&quot;) #添加模块，模块名要和模块文件夹名一致</code></pre><h2 id="主框架QT模块CMakeLists-txt"><a href="#主框架QT模块CMakeLists-txt" class="headerlink" title="主框架QT模块CMakeLists.txt"></a>主框架QT模块CMakeLists.txt</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">#----------------------------------------------------------------------------------FIND_PACKAGE( Qt5Widgets REQUIRED ) #寻找Qt的Widgets模块，5为Qt版本FIND_PACKAGE( Qt5Core REQUIRED ) #寻找Qt的Core核心模块FIND_PACKAGE( Qt5Gui REQUIRED ) #寻找Qt的Gui模块#设置VTK库Debug还是Release版本，设置路径VTK_DIR便于调用 FIND_PACKAGE( VTK )SET(VTK_DIR $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;third_part_library&#x2F;VTK&#x2F;VTK-8.2.0&#x2F;VTK-8.2.0-Install-VS2017-x64-Debug&#x2F;lib&#x2F;cmake&#x2F;vtk-8.2)#VTK的Debug版本库和Release版本库部分模块文件不一致，不可混用，因此在发布时需要设置为Release版本# 查找并包含VTK工具包FIND_PACKAGE( VTK ) #寻找VTK第三方库IF (VTK_FOUND)        INCLUDE ($&#123;VTK_USE_FILE&#125;)        #如果找到，则包含$&#123;VTK_USE_FILE&#125;中的配置文件ELSE (VTK_FOUND)        MESSAGE (FATAL_ERROR &quot;Cannot build without VTK. Please set VTK_DIR&quot;)        #如果没找到，则输出错误信息，找不到VTK，请设置VTK_DIRENDIF( VTK_FOUND )#----------------------------------------------------------------------------------SET(CMAKE_INCLUDE_CURRENT_DIR ON) #启用当前CMake当前路径SET(CMAKE_AUTOMOC ON) #Qt编译设置SET(CMAKE_AUTORCC ON) #Qt编译设置SET(CMAKE_AUTOUIC ON) #Qt编译设置#主要是用来对.ui文件和.qrc等QT独有的资源文件进行编译SET(CMAKE_BUILD_TYPE DEBUG) #设置为Debug运行方式#----------------------------------------------------------------------------------INCLUDE($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;third_part_library&#x2F;VTK&#x2F;VTKMFCSettings.cmake) #包含VTK模块配置文件SET( VTK_LIBS #设置VTK静态库vtkGUISupportQt #添加vtkGUISupportQt-8.2.lib静态库vtkIOCorevtkRenderingCorevtkFiltersCorevtkFiltersSourcesvtkInteractionWidgetsvtkCommonCorevtkImagingCorevtkRenderingOpenGL2vtkInteractionStylevtkRenderingAnnotationvtkRenderingFreeTypevtkRenderingGL2PSOpenGL2vtkIOImagevtkIOGeometryvtkFiltersExtractionvtkCommonColorvtkFiltersGeometryvtkFiltersModeling)#设置VTK动态库IF(VTK_MFC_DELAYLOAD_VTK_DLLS)        VTK_MFC_ADD_DELAYLOAD_FLAGS(CMAKE_EXE_LINKER_FLAGS)ENDIF(VTK_MFC_DELAYLOAD_VTK_DLLS)#----------------------------------------------------------------------------------#添加头文件、源文件、资源文件FILE(GLOB_RECURSE HeaderFiles &quot;inc&#x2F;*.h&quot;) #设置.h头文件SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;HeaderFiles&#125;) #在QtCreator中根据当前目录结构创建头文件夹FILE(GLOB_RECURSE SourceFiles &quot;src&#x2F;*.cpp&quot;) #设置.cpp源文件SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;SourceFiles&#125;)#在QtCreator中根据当前目录结构创建源文件夹FILE(GLOB_RECURSE ResourceFiles &quot;res&#x2F;*.qrc&quot;) #设置.qrc资源文件SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;ResourceFiles&#125;)#在QtCreator中根据当前目录结构创建资源文件夹FILE(GLOB_RECURSE UIFiles &quot;src&#x2F;*.ui&quot;) #设置.ui设计师界面文件SOURCE_GROUP(&quot;ui&quot; FILES $&#123;UIFiles&#125;)#在QtCreator中根据当前目录结构创建设计师界面文件夹#----------------------------------------------------------------------------------#使用指定的源文件来生成可执行文件Evaluation_QT，应该可以只包含#$&#123;UIFiles&#125;#$&#123;SourceFiles&#125;#$&#123;ResourceFiles&#125;#三个路径即可，嫌麻烦，直接全部指定ADD_EXECUTABLE( Public_QT WIN32 $&#123;HeaderFiles&#125;$&#123;UIFiles&#125;$&#123;SourceFiles&#125;$&#123;ResourceFiles&#125;)#包含头文件TARGET_INCLUDE_DIRECTORIES(Public_QT PUBLIC$&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;inc$&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;res)#包含库文件，即链接其他模块（其他模块编译时生成dll，此处便是将其链接起来）TARGET_LINK_LIBRARIES (Public_QTPublic_VTK$&#123;VTK_LIBS&#125;Qt5::WidgetsQt5::CoreQt5::Gui)#-----------------------------------------------------------------------------------</code></pre><h2 id="子VTK模块CMakeLists-txt"><a href="#子VTK模块CMakeLists-txt" class="headerlink" title="子VTK模块CMakeLists.txt"></a>子VTK模块CMakeLists.txt</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">#----------------------------------------------------------------------------------MESSAGE(&quot;VTK---$&#123;PROJECT_SOURCE_DIR&#125;&quot;) #输出变量值，编译时方便查看路径是否错误#----------------------------------------------------------------------------------# 查找并包含VTK工具包FIND_PACKAGE( VTK )IF (VTK_FOUND)INCLUDE ($&#123;VTK_USE_FILE&#125;)ELSE (VTK_FOUND)MESSAGE (FATAL_ERROR &quot;Cannot build without VTK. Please set VTK_DIR&quot;)ENDIF( VTK_FOUND )#----------------------------------------------------------------------------------SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib) # 指定动态库输出目录FILE(GLOB_RECURSE HeaderFiles &quot;inc&#x2F;*.h&quot;)SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;HeaderFiles&#125;)FILE(GLOB_RECURSE SourceFiles &quot;src&#x2F;*.cpp&quot;)SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;SourceFiles&#125;)FILE(GLOB_RECURSE ResourceFiles &quot;res&#x2F;*.rc&quot;)SOURCE_GROUP(TREE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; FILES $&#123;ResourceFiles&#125;)#Public_VTK 名字一定不能错，需要和顶层CMakeList.txt以及Qt主框架CmakeLists.txt匹配ADD_LIBRARY(Public_VTK $&#123;HeaderFiles&#125; $&#123;SourceFiles&#125; $&#123;ResourceFiles&#125;)TARGET_INCLUDE_DIRECTORIES(Public_VTK PUBLIC $&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;inc)#----------------------------------------------------------------------------------</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;简单介绍CMake软件即CMakeLists.txt作用和功能。&lt;br&gt;&amp;emsp;&amp;emsp;CMmke常用于跨平</summary>
      
    
    
    
    <category term="RobotCAM软件开发" scheme="http://lucaslyf.gitee.io/categories/RobotCAM%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RobotCAM(一):环境搭建</title>
    <link href="http://lucaslyf.gitee.io/2021/08/01/RobotCAM-%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://lucaslyf.gitee.io/2021/08/01/RobotCAM-%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-08-01T14:11:54.000Z</published>
    <updated>2022-11-15T08:38:12.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;RobotCAM机器人轨迹仿真平台基于Qt5.14.2进行搭建，使用CMake进行第三方库管理。<br>&emsp;&emsp;需要安装VS2017、Qt5.14.2两个软件。<br>&emsp;&emsp;第三方库直接使用我配置好的即可。</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="VS2017安装"><a href="#VS2017安装" class="headerlink" title="VS2017安装"></a>VS2017安装</h3><p>&emsp;&emsp;<a href="https://msdn.itellyou.cn/">MSDN神站下载</a>，进入如图所示页面，选择VS2017任意版本进行下载（推荐安装专业版）。<br><img src="VS2017%E4%B8%8B%E8%BD%BD.jpg" alt="VS2017下载"><br>&emsp;&emsp;下载完成后，打开在线安装包（安装完成后不要删掉安装包，方便以后进行组件修改），按照如图所示配置。<br><img src="VS2017%E5%AE%89%E8%A3%85.jpg" alt="VS2017安装"></p><h3 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h3><p>&emsp;&emsp;<a href="https://www.qt.io/download">Qt官网进行下载</a>，注册一个自己的账号，点击如图所示进行Qt在线安装包下载。<br><img src="%E4%B8%8B%E8%BD%BDQt.jpg" alt="Qt下载"><br>&emsp;&emsp;Qt安装方式为在线安装，可能比较慢，耐心等待一下就好。后期修改版本或者增添新组件比较方便。<br>&emsp;&emsp;下载完成后打开Qt在线安装，按照如图所示，勾选红框处，其余保持默认。<br><img src="Qt%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE.jpg" alt="Qt安装"></p><h3 id="Qt运行测试"><a href="#Qt运行测试" class="headerlink" title="Qt运行测试"></a>Qt运行测试</h3><p>&emsp;&emsp;安装完VS2017和Qt5.14.2后，打开QtCreator，进入如图所示界面，搜索“sdi”案例。<br><img src="Qt%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95.jpg" alt="Qt测试"><br>&emsp;&emsp;保持默认配置，F5运行sdi案例，若能成功运行，没有报错，即完成软件安装。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>&emsp;&emsp;在Q群中下载我提供的基本平台源码，直接解压到“D:\”，即D盘根目录下。（最好保持目录结构和图片一致）<br><img src="%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg" alt="文件结构"><br>&emsp;&emsp;打开“环境变量和QT设置.txt”按照内容进行配置。</p><h3 id="Path设置"><a href="#Path设置" class="headerlink" title="Path设置"></a>Path设置</h3><p>&emsp;&emsp;右键“此电脑”-&gt;属性-&gt;高级系统设置-&gt;环境变量，进入如图所示页面。<br><img src="Path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="Path变量"><br>&emsp;&emsp;双击红框处，添加Path路径，将“环境变量和QT设置.txt”对应内容填入，如果路径不同，根据自己的情况修改。<br>&emsp;&emsp;配置完后如图所示。（前期入门训练只用到了VTK库，Evaluation(v1.0)没有提供其他的第三方库，可以只设置VTK的环境变量，全部设置好也没影响）<br><img src="%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE.jpg" alt="环境变量"></p><h2 id="软件平台运行测试"><a href="#软件平台运行测试" class="headerlink" title="软件平台运行测试"></a>软件平台运行测试</h2><p>&emsp;&emsp;做完以上所有操作后，打开QtCreator-&gt;工具-&gt;选项-&gt;构建和运行，修改为如图所示配置。<br><img src="Qt%E8%AE%BE%E7%BD%AE.jpg" alt="Qt设置"><br>&emsp;&emsp;接着点击“打开”，选择如图所示“CMakeLists.txt”文件。<br><img src="%E8%BD%AF%E4%BB%B6%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95.jpg" alt="运行测试"><br>&emsp;&emsp;然后F5运行，如果没有报错，且界面交互一切正常，则配置完成。（成功运行后界面如图所示）<br><img src="%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C.jpg" alt="成功运行"></p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>&emsp;&emsp;1.VS2017组件安装缺失。<br>&emsp;&emsp;2.QT版本冲突导致qmake使用的是旧版本，无法匹配。<br>&emsp;&emsp;3.修改了文件名，导致CMake路径配置错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;RobotCAM机器人轨迹仿真平台基于Qt5.14.2进行搭建，使用CMake进行第三方库管理。&lt;br&gt;&amp;emsp;</summary>
      
    
    
    
    <category term="RobotCAM软件开发" scheme="http://lucaslyf.gitee.io/categories/RobotCAM%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>RobotCAM:(问题记录)</title>
    <link href="http://lucaslyf.gitee.io/2021/07/31/RobotCAM-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://lucaslyf.gitee.io/2021/07/31/RobotCAM-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2021-07-30T18:03:22.000Z</published>
    <updated>2022-11-15T08:38:12.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;此贴主要记录RobotCAM软件开发过程中遇到的奇怪和难点问题。</p><h2 id="QtCreator-Debug模式下加载QFileDialog十分缓慢"><a href="#QtCreator-Debug模式下加载QFileDialog十分缓慢" class="headerlink" title="QtCreator Debug模式下加载QFileDialog十分缓慢"></a>QtCreator Debug模式下加载QFileDialog十分缓慢</h2><p>&emsp;&emsp;排查后发现程序没有问题、环境配置没有问题。重装VS和QT后还是无效。怀疑是注册表清理出问题，查看注册表基本确定问题不是由注册表引起。最后发现QtCreator中有无效断点（断点列表里存在断点，双击跟进断点位置不在代码处）。清空无效断点后程序运行正常。算是QtCreator的一个BUG，记录一下。</p><h2 id="Boost1-75版本库使用-boost-archive-xml-iarchive序列化时析构函数抛出错误"><a href="#Boost1-75版本库使用-boost-archive-xml-iarchive序列化时析构函数抛出错误" class="headerlink" title="Boost1_75版本库使用 boost::archive::xml_iarchive序列化时析构函数抛出错误"></a>Boost1_75版本库使用 boost::archive::xml_iarchive序列化时析构函数抛出错误</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool GetConvertData(std::list&lt;Convert::Region2d*&gt;&amp; loops, const char * szPath)&#123;    if (!szPath)        return false;    std::ifstream binary_sstream(szPath, std::ios::binary | std::ios::in);&#x2F;&#x2F;读取文件    &quot;std::string sdd;&quot;    if (binary_sstream.is_open()&amp;&amp; binary_sstream.good())&#x2F;&#x2F;判断文件是否打开以及是否合法    &#123;        boost::archive::xml_iarchive binary_oa(binary_sstream);&#x2F;&#x2F;将文件流序列化        try        &#123;            ...        &#125;        catch (boost::archive::archive_exception const&amp; e)        &#123;            binary_sstream.close();            return false;        &#125;        &quot;binary_sstream&gt;&gt;sdd;&quot;        binary_sstream.close();&#x2F;&#x2F;关闭文件流        return true;&#x2F;&#x2F;返回值，进入析构函数        &#x2F;&#x2F;运行到这里.bin文件中的数据已经全部拿到，但是xml_iarchive析构函数抛出异常    &#125;    return false;&#125;</code></pre><p>&emsp;&emsp;分析可能是高版本Boost库特性导致，文件流打开文件后没有调用，直接关闭后数据没有正常析构。因此导致xml_iarchive认为文件流没有正常关闭，抛出异常。添加引号中调用文件流代码后程序正常运行。   </p><h2 id="Qt运行提示”无法打开rc-exe”"><a href="#Qt运行提示”无法打开rc-exe”" class="headerlink" title="Qt运行提示”无法打开rc.exe”"></a>Qt运行提示”无法打开rc.exe”</h2><p><img src="%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80rc.exe.png" alt="Qt设置"></p><p>&emsp;&emsp;确认完整搭建好环境后，打开QtCreator，进入：工具-&gt;选项-&gt;构建和运行。取消勾选如图所示红框处即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;此贴主要记录RobotCAM软件开发过程中遇到的奇怪和难点问题。&lt;/p&gt;
&lt;h2 id=&quot;QtCreator-Deb</summary>
      
    
    
    
    <category term="RobotCAM软件开发" scheme="http://lucaslyf.gitee.io/categories/RobotCAM%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
